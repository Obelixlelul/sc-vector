<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>A Canvas for Drawing: Introdução</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">A Canvas for Drawing
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Introdução </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Esse é um mini-projeto de implementação que faz parte do <em>Projeto Jogo da Vida</em> da 2a Unidade de LP1.</p>
<p>O objetivo desse projeto é desenvolver uma classe que representa um abstração de um canvas para desenho. Esse canvas deve ser capaz de suportar operações de desenho simples, como definir a cor de fundo e definir a cor de um pixel, por exemplo.</p>
<p>Uma vez realizado desenhos em um objeto do tipo canvas, o objeto deve ser capaz de retornar um ponteiro para os dados do desenho armazenados na memória. Por sua vez, a organização dos dados na memória segue o formato de uma imagem do tipo <a href="https://en.wikipedia.org/wiki/Netpbm_format">PPM</a>.</p>
<p>Isso quer dizer que cada pixel deve possuir 4 canais, R, G, B e Alpha, embora o canal Alpha não seja utilizado na prática no projeto Jogo da Vida.</p>
<h1>Contexto de Uso do Canvas</h1>
<p>Para você entender melhor o funcionamento e motivação do canvas, é importante saber em que contexto ele será necessário.</p>
<p>O Projeto Jogo da Vida consiste em simular um <a href="https://en.wikipedia.org/wiki/Cellular_automaton"><em>cellular automaton</em></a>, que basicamente é uma simulação discreta que ocorre sobre um tabuleiro de dimensões <em>W x H</em> (largura x altura). Nesse tabuleiro, uma célula pode ser definida inicialmente como <b>viva</b> ou <b>morta</b>. A cada passo da simulação, todas as células do tabuleiro são avaliadas de acordo com um conjunto de regras; o resultado dessa avaliação é que algumas células vivas morrerão e outras células nascerão.</p>
<p>Nesse momento, não vamos entrar em detalhes sobre como o processo de atualização e aplicação de regras vai funcionar (isso será descrito no Projeto Jogo da Vida). O importante é saber que a cada passo da simulação precisamos gerar uma <b>imagem</b> que represente o estado do tabuleiro naquela <em>iteração</em> (ou geração) da simulação. Nessa representação visual, as células vivas serão exibidas em uma certa cor, e as demais células (mortas ou inexistentes) com a cor de fundo.</p>
<p>É por esse motivo que o projeto precisa de um mecanismo para gerar uma imagem a partir dos dados da simulação. É nesse momento que surge a necessidade da classe <code>Canvas</code> cujo objetivo é justamente produzir uma imagem a partir dos dados da simulação. Nesse caso podemos afirmar que o Jogo da Vida (aplicação) será o <b>cliente</b> da classe <code>Canvas</code>.</p>
<p>Veja a imagem abaixo com um exemplo de saída da simulação.</p>
<img src="./pics/generation_0001.png" width="150" alt="" class="inline"/>
<p>A imagem acima corresponde a um tabuleiro do jogo da vida com <em>W=10</em> por <em>H=10</em>. Os pixeis em vermelho representam as células vivas e as demais células são exibidas em verde claro.</p>
<p>Em resumo, precisamos de uma classe que suporte:</p><ol type="1">
<li>Definir uma cor de fundo ou de células vazias e/ou mortas;</li>
<li>"_Pintar_" os pixeis de uma imagem com uma cor específica (células vivas), e;</li>
<li>Enviar essa matriz de pixeis coloridos para uma função externa que grave essas informações em formato <em>png</em>, por exemplo.</li>
</ol>
<p>Essas ações corresponderão a três métodos da classe <code>Canvas</code>.</p>
<h1>Canvas Virtual <em>vs</em> Canvas Real</h1>
<p>Como demonstrado em sala de aula, se utilizarmos um mapeamento 1-para-1 entre uma célula viva do Projeto Jogo da Vida e um pixel na imagem de saída, a imagem resultante será muito pequena e difícil de visualizar.</p>
<p>Para demonstrar esse exemplo, suponha que desejamos gerar um <em>checkerboard</em> (tabuleiro quadriculado, similar ao de xadrez) de tamanho <em>W = 20</em> x <em>H = 15</em>. Se o mapeamento for 1-para-1, ou seja, uma célula colorida para um pixel, a imagem resultado seria a exibida abaixo. É possível perceber que a imagem é muito pequena, com dimensões <em>20 x 15</em> pixeis.</p>
<img src="./pics/saida_1.png" alt="" class="inline"/>
<p>Para contornar o problema de conseguir visualizar tabuleiros de pequenas dimensões, podemos permitir que o usuário especifique um <b>pixel virtual</b>. Para isso, basta que o cliente defina a dimensão do pixel virtual como sendo um inteiro <code>block_size</code> &gt;= 1. Quanto maior o <code>block_size</code> maior será a imagem resultante. Por exemplo, o mesmo <em>checkerboard</em> acima foi gerada com <code>block_size</code> = 50, ou seja, um pixel no canvas virtual corresponde a um <em>quadrado</em> 50x50 na imagem real.</p>
<p>Isso quer dizer que no exemplo o cliente especificou que desejava uma imagem <em>W</em>=20 x <em>H</em>=15 com <code>block_size</code> = 50. Como resultado, a imagem no canvas real acabou com dimensões 1000 x 750, visto que cada <em>pixel virtual</em> ocupa um bloco de 50 x 50 <em>pixeis reais</em>.</p>
<img src="./pics/saida_50.png" alt="" class="inline"/>
<h1>Implementando a Solução Proposta</h1>
<p>Para permitir a criação de um canvas virtual maior, vamos solicitar ao cliente que informe o <code>block_size</code>, ou seja, a dimensão do pixel virtual. Dessa forma o cliente ainda vai indicar o tamanho do canvas correspondente ao número de linhas e colunas do seu tabuleiro, por exemplo <em>W=20</em> x <em>H=15</em>, mas agora com a possibilidade de definir o tamanho do pixel, como acima com <code>block_size=50</code>.</p>
<p>A imagem resultante final (retornada pelo objeto <code>Canvas</code>) será na verdade uma imagem de largura <code>Width=1000</code> por altura <code>Height=750</code>, visto que cada "pixel" virtual ocupa, na verdade, um quadrado de 50 x 50 pixeis reais.</p>
<p>Considere o código abaixo como exemplo</p>
<div class="fragment"><div class="line">Canvas canv{ 20, 15, 50 };          // Cria um canvas com W=20 x H=15 e block size = 50.</div><div class="line"></div><div class="line">canv.clear( YELLOW );               // Pinta todo canvas de amarelo.</div><div class="line">canv.pixel( Point2{ 8, 5}, BLUE );  // Solicita que o pixel (8,5) seja pintado de azul.</div></div><!-- fragment --><p>Nesse exemplo, o cliente pede que a posição <code>(8,5)</code> seja pintada de cor azul. Contudo, o que vai acontecer na verdade é que um quadrado de <em>50 x 50</em> a partir da posição <code>(400,250)</code> será pintado de azul na imagem final. Em outras palavras, estamos abstraindo para o cliente um mapeamento entre a posição original <code>(8,5)</code> para a posição real <code>(400,250)</code> e, simultaneamente, mapeando 1 pixel para um quadrado de <em>50 x 50</em>.</p>
<h1>O Que Devo Fazer?</h1>
<p>Sua tarefa, portanto, consiste em implementar a classe <code>Canvas</code> para suportar as funcionalidade definidas acima. Para tanto, você pode seguir a sugestão de interface para a classe presente no arquivo <a href="include/canvas.h"><code>canvas.h</code></a>. O projeto também possui um outro cabeçalho, <a href="include/common.h"><code>common.h</code></a> que define algumas estruturas que podem ajudar na implementação, como uma estrutura para representar posição na matriz, uma para representar um pixel na imagem e uma para representar uma cor RGB. Para uma melhor compreensão do código oferecido, acesse a documentação do projeto <a href="docs/html/index.html">aqui</a>.</p>
<p>No projeto também existe um programa de teste, denominado <a href="src/driver_canvas.cpp"><code>driver_canvas.cpp</code></a> que cria um canvas e gera um <em>checkerboard</em>. A imagem resultante, se o canvas foi implementado corretamente, corresponderá a <a href="build/test.png">essa image</a>. Vale destacar que em uma imagem a <b>origem</b> do sistema de coordenadas é no <em>canto inferior esquerdo</em>, ou seja, o eixo Y positivo aponta para cima. É por esse motivo que o pixel <code>(0,0)</code> pintado de verde dentro do <code>driver_canvas.cpp</code> aparece no canto <em>inferior</em> esquerdo da imagem-exemplo, e não no canto <em>superior</em> esquerdo. Em resumo, o sistema de coordenadas da imagem é diferente do sistema de coordenadas de uma matriz.</p>
<p>Note que o projeto utiliza uma biblioteca externa, <a href="https://github.com/lvandeve/lodepng/blob/master/examples/example_encode.cpp">lodepng</a>, para gravar (codificar) uma imagem png. Contudo não é necessário instalar a biblioteca; basta copiar o arquivo <code>lodepng.cpp</code> para a pasta <code>src</code> e o arquivo <code>lodepng.h</code> para a pasta <code>include</code> e compilar o seu projeto normalmente com o <a href="CMakeLists.txt">cmake script</a> disponível. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
